<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Wish | 3D Interactive Experience</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap" rel="stylesheet">

    <style>
        /* --- Visuals: Minimalist Luxury --- */
        :root {
            --bg-color: #000000;
            --gold: #d4af37;
            --gold-dim: #8a7020;
            --glass: rgba(255, 255, 255, 0.05);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--gold);
            font-family: 'Times New Roman', serif;
            user-select: none;
            touch-action: none;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            font-family: 'Cinzel', serif;
            text-align: center;
            font-size: 3rem;
            margin-top: 2rem;
            letter-spacing: 5px;
            background: linear-gradient(to right, #bf953f, #fcf6ba, #b38728, #fbf5b7, #aa771c);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            pointer-events: auto;
        }

        .controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
        }

        .btn-group { display: flex; gap: 10px; }

        .btn {
            background: var(--glass);
            border: 1px solid var(--gold);
            color: var(--gold);
            padding: 12px 25px;
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-radius: 4px;
        }

        .btn:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
        }

        /* Status Indicator */
        #gesture-status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--gold);
            font-family: 'Cinzel', serif;
            font-size: 0.8rem;
            border: 1px solid var(--gold-dim);
            padding: 8px 12px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
            border-radius: 4px;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 2px solid transparent;
            border-top: 2px solid var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            box-shadow: 0 0 15px var(--gold);
        }

        .loading-text {
            margin-top: 20px;
            font-family: 'Cinzel', serif;
            color: var(--gold);
            letter-spacing: 3px;
        }

        #file-input { display: none; }

        /* Video Container (Mirrored) */
        .webcam-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid var(--gold);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
            z-index: 90;
            transform: scaleX(-1);
            background: #000;
        }
        
        #webcam { width: 100%; height: 100%; object-fit: cover; }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        @media (max-width: 768px) {
            h1 { font-size: 2rem; margin-top: 1rem; }
            .webcam-container { width: 100px; height: 75px; bottom: 10px; left: 10px; }
            .controls { width: 90%; }
        }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
    </script>
</head>
<body>

    <audio id="bg-music" loop>
        <source src="https://cdn.pixabay.com/audio/2024/11/18/audio_f1997e9f78.mp3" type="audio/mpeg">
    </audio>

    <div id="loading-screen">
        <div class="spinner"></div>
        <div class="loading-text">Manifesting Holiday Spirit...</div>
    </div>

    <div id="ui-container">
        <h1>Christmas Wish</h1>
        <div id="gesture-status">Mode: Loading AI...</div>
        <div class="controls">
            <div class="btn-group">
                <button class="btn" id="upload-btn">Add Memories</button>
                <button class="btn" id="music-btn">♪ Play Music</button>
            </div>
            <input type="file" id="file-input" accept="image/*" multiple>
        </div>
    </div>

    <div class="webcam-container">
        <video id="webcam" autoplay playsinline muted></video>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, composer, controls;
        let particles = [], snowParticles = [];
        let particleGroup, snowGroup, starMesh; // Added starMesh
        
        // MediaPipe
        let handLandmarker, webcam;
        let lastVideoTime = -1;
        let lastDetectionTime = 0;
        let detectionInterval = 100; // Throttle AI (10FPS)
        let handResults = undefined;
        
        // State Machine
        const STATES = { TREE: 'TREE', SCATTER: 'SCATTER', FOCUS: 'FOCUS' };
        let currentState = STATES.TREE;
        let pendingState = null;
        let stateHoldTimer = 0;
        let lastCheckTime = 0;
        const STATE_HOLD_THRESHOLD = 200; // Debounce time
        
        // Motion
        let targetRotation = new THREE.Vector2(0, 0); 
        let currentRotation = new THREE.Vector2(0, 0);
        let focusedPhotoIndex = -1;
        
        const PARTICLE_COUNT = 1500;
        
        async function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.015); // Slightly denser fog for depth

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 14);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            // Lighting (Visual Quality Restored)
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            const spotLight = new THREE.SpotLight(0xd4af37, 30); // High intensity
            spotLight.position.set(5, 20, 5);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.5;
            scene.add(spotLight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // Post-Processing
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.15; // Lower threshold for more glow
            bloomPass.strength = 1.0; 
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(new OutputPass());

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            
            // --- CREATE OBJECTS ---
            createParticles();
            createSnowParticles();
            createStar(); // New Star Function
            setupUI();
            
            // Init AI
            setupMediaPipe().then(() => {
                const ls = document.getElementById('loading-screen');
                ls.style.opacity = '0';
                setTimeout(() => ls.remove(), 1000);
            });

            animate();
        }

        // --- 1. VISUALS RESTORATION: Candy Cane Geometry ---
        function createCandyCaneGeometry() {
            class CustomSinCurve extends THREE.Curve {
                constructor(scale = 1) { super(); this.scale = scale; }
                getPoint(t, optionalTarget = new THREE.Vector3()) {
                    let x, y, z;
                    if(t < 0.7) {
                        x = 0; y = t * 4; z = 0;
                    } else {
                        const theta = (t - 0.7) / 0.3 * Math.PI;
                        x = Math.sin(theta) * 0.5;
                        y = 2.8 + Math.cos(theta) * 0.5;
                        z = 0;
                    }
                    return optionalTarget.set(x, y, z).multiplyScalar(this.scale);
                }
            }
            return new THREE.TubeGeometry(new CustomSinCurve(0.2), 20, 0.02, 8, false);
        }

        // --- NEW: Star Generation ---
        function createStar() {
            if(!particleGroup) return;

            const shape = new THREE.Shape();
            const points = 5;
            const outerRadius = 0.8;
            const innerRadius = 0.35;

            for (let i = 0; i < points * 2; i++) {
                // Angle starting from top (PI/2)
                const a = (i / (points * 2)) * Math.PI * 2 + Math.PI / 2;
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                const x = Math.cos(a) * r;
                const y = Math.sin(a) * r;
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            shape.closePath();

            const extrudeSettings = { 
                depth: 0.25, 
                bevelEnabled: true, 
                bevelSegments: 2, 
                steps: 1, 
                bevelSize: 0.05, 
                bevelThickness: 0.05 
            };
            const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geo.center(); // Pivot at center

            // REDUCED BRIGHTNESS: Emissive intensity 0.7 (was 1.0)
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                emissive: 0xffaa00,
                emissiveIntensity: 0.7, 
                roughness: 0.1, 
                metalness: 1.0 
            });

            starMesh = new THREE.Mesh(geo, mat);
            // Tree height is approx 10, range is roughly -5 to +5.
            starMesh.position.set(0, 5.5, 0); 
            
            // Add to group so it rotates with tree
            particleGroup.add(starMesh);
        }

        // --- 2. VISUALS RESTORATION: High Quality Particles ---
        function createParticles() {
            particleGroup = new THREE.Group();
            scene.add(particleGroup);

            // Restore High Quality Geometries
            const boxGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const sphereGeo = new THREE.SphereGeometry(0.06, 16, 16); // High poly
            const caneGeo = createCandyCaneGeometry(); // Procedural geometry
            // [MODIFICATION 1] Add Snowflake/Crystal Geometry
            const crystalGeo = new THREE.OctahedronGeometry(0.07, 0); 
            
            // Restore High Quality Materials (PBR)
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, roughness: 0.1, metalness: 0.9 });
            const redMat = new THREE.MeshStandardMaterial({ color: 0x8a0000, roughness: 0.2, metalness: 0.6 });
            const greenMat = new THREE.MeshStandardMaterial({ color: 0x003300, roughness: 0.2, metalness: 0.6 });
            // [MODIFICATION 1] Add White Ice/Snow Material
            const snowMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.2, 
                metalness: 0.2,
                emissive: 0xffffff,
                emissiveIntensity: 0.4 
            });

            const geometries = [boxGeo, sphereGeo, caneGeo, crystalGeo];
            const materials = [goldMat, redMat, greenMat, snowMat];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const geo = geometries[Math.floor(Math.random() * geometries.length)];
                const mat = materials[Math.floor(Math.random() * materials.length)];
                
                const mesh = new THREE.Mesh(geo, mat);
                
                // Tree Formation
                const angle = i * 0.15; 
                const height = 10;
                const y = (i / PARTICLE_COUNT) * height - (height / 2);
                const radius = 3.5 * (1 - (y + height/2) / height);
                const treePos = new THREE.Vector3(
                    Math.cos(angle) * radius + (Math.random() - 0.5) * 0.2,
                    y,
                    Math.sin(angle) * radius + (Math.random() - 0.5) * 0.2
                );

                // Scatter Formation
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 6 + Math.random() * 4;
                const scatterPos = new THREE.Vector3(
                    r * Math.cos(theta) * Math.sin(phi),
                    r * Math.sin(theta) * Math.sin(phi),
                    r * Math.cos(phi)
                );

                mesh.position.copy(scatterPos);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                
                mesh.userData = {
                    treePos: treePos,
                    scatterPos: scatterPos,
                    rotationSpeed: new THREE.Vector3((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02, 0),
                    isPhoto: false,
                    baseScale: 1,
                    aspect: 1
                };

                particleGroup.add(mesh);
                particles.push(mesh);
            }
        }

        function createSnowParticles() {
            snowGroup = new THREE.Group();
            scene.add(snowGroup);
            const snowGeo = new THREE.SphereGeometry(0.03, 8, 8);
            const snowMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, roughness: 0.8, emissive: 0x222222, emissiveIntensity: 0.2 
            });

            for (let i = 0; i < 2000; i++) {
                const mesh = new THREE.Mesh(snowGeo, snowMat);
                mesh.position.set((Math.random()-0.5)*40, Math.random()*20, (Math.random()-0.5)*40);
                mesh.userData = {
                    velocity: new THREE.Vector3((Math.random()-0.5)*0.02, -0.05-Math.random()*0.05, (Math.random()-0.5)*0.02)
                };
                snowGroup.add(mesh);
                snowParticles.push(mesh);
            }
        }

        function addPhoto(imgUrl) {
            const loader = new THREE.TextureLoader();
            loader.load(imgUrl, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                const aspect = texture.image.width / texture.image.height;
                // High quality photo material
                const mat = new THREE.MeshStandardMaterial({ 
                    map: texture, 
                    roughness: 0.7, 
                    metalness: 0.0,
                    side: THREE.DoubleSide
                });
                
                const frameMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 1.0, roughness: 0.1 });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), mat);
                const frame = new THREE.Mesh(new THREE.BoxGeometry(1.02, 1.02, 0.05), frameMat);
                frame.position.z = -0.03;
                mesh.add(frame);

                const idx = Math.floor(Math.random() * particles.length);
                const old = particles[idx];
                mesh.position.copy(old.position);
                mesh.userData = { ...old.userData, isPhoto: true, aspect: aspect };
                particleGroup.remove(old);
                particleGroup.add(mesh);
                particles[idx] = mesh;
            });
        }

        // --- 3. OPTIMIZED AI ---
        async function setupMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "CPU" // Safe mode
                    },
                    runningMode: "VIDEO",
                    numHands: 1,
                    minHandDetectionConfidence: 0.6,
                    minHandPresenceConfidence: 0.6,
                    minTrackingConfidence: 0.6
                });
                
                webcam = document.getElementById('webcam');
                // Request slightly lower res for performance
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 480, height: 360, frameRate: 30 } }); 
                webcam.srcObject = stream;
                
                document.getElementById('gesture-status').innerText = "Mode: Camera Active";
            } catch (err) {
                console.error(err);
                document.getElementById('gesture-status').innerText = "AI Failed";
            }
        }

        function detectGestures() {
            const now = Date.now();
            
            // Throttle: Max 10 checks per second
            if (!handLandmarker || !webcam || webcam.paused || (now - lastDetectionTime < detectionInterval)) {
                return;
            }
            lastDetectionTime = now;

            if (webcam.currentTime !== lastVideoTime) {
                lastVideoTime = webcam.currentTime;
                try {
                    handResults = handLandmarker.detectForVideo(webcam, now);
                } catch(e) { console.warn("MP Error", e); }
            }

            const statusDiv = document.getElementById('gesture-status');

            if (handResults && handResults.landmarks.length > 0) {
                const lm = handResults.landmarks[0];
                
                // Normalized Hand Coordinates for Rotation
                targetRotation.set((lm[9].y - 0.5) * 2, (lm[9].x - 0.5) * 2);

                // Adaptive Distances
                function dist(a, b) { return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2 + (a.z-b.z)**2); }
                const handSize = dist(lm[0], lm[9]); 
                
                const pinch = dist(lm[4], lm[8]) / handSize;
                const open = (dist(lm[8], lm[0]) + dist(lm[12], lm[0]) + dist(lm[16], lm[0]) + dist(lm[20], lm[0])) / 4 / handSize;

                let detected = currentState;
                if (pinch < 0.35) detected = STATES.FOCUS;
                else if (open > 1.3) detected = STATES.SCATTER;
                else if (open < 0.9) detected = STATES.TREE;

                // Debounce Logic
                if (detected !== currentState) {
                    if (detected === pendingState) {
                        stateHoldTimer += (now - lastCheckTime);
                        if (stateHoldTimer > STATE_HOLD_THRESHOLD) {
                            if (detected === STATES.FOCUS && currentState !== STATES.FOCUS) {
                                const photos = particles.filter(p => p.userData.isPhoto);
                                if (photos.length > 0) focusedPhotoIndex = particles.indexOf(photos[Math.floor(Math.random() * photos.length)]);
                            }
                            currentState = detected;
                            stateHoldTimer = 0;
                        }
                    } else {
                        pendingState = detected;
                        stateHoldTimer = 0;
                    }
                } else {
                    pendingState = null;
                    stateHoldTimer = 0;
                }
                
                controls.enabled = false;
                statusDiv.innerText = `Gesture: ${currentState}`;
                statusDiv.style.opacity = 1;
            } else {
                controls.enabled = true;
                targetRotation.set(0, 0);
                statusDiv.style.opacity = 0.5;
            }
            lastCheckTime = now;
        }

        function setupUI() {
            document.getElementById('upload-btn').onclick = () => document.getElementById('file-input').click();
            document.getElementById('file-input').onchange = (e) => {
                if(e.target.files[0]) Array.from(e.target.files).forEach(f => addPhoto(URL.createObjectURL(f)));
            };
            
            const btn = document.getElementById('music-btn');
            const audio = document.getElementById('bg-music');
            btn.onclick = () => {
                audio.paused ? (audio.play(), btn.innerText = "♪ Pause Music") : (audio.pause(), btn.innerText = "♪ Play Music");
            };
            window.onresize = () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            };
        }

        // --- 4. ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);
            detectGestures(); 

            const time = Date.now() * 0.001;

            if (currentState !== STATES.FOCUS) {
                currentRotation.lerp(targetRotation, 0.1);
                if(!controls.enabled) {
                    // [MODIFICATION 2] Force tree vertical in TREE mode
                    if (currentState === STATES.TREE) {
                        particleGroup.rotation.x = THREE.MathUtils.lerp(particleGroup.rotation.x, 0, 0.1);
                        particleGroup.rotation.y = currentRotation.y;
                    } else {
                        // Allow free rotation/tilt in SCATTER mode
                        particleGroup.rotation.x = currentRotation.x;
                        particleGroup.rotation.y = currentRotation.y;
                    }
                } else {
                    particleGroup.rotation.y += 0.002;
                    particleGroup.rotation.x *= 0.95;
                }
            } else {
                // Stabilize logic
                particleGroup.rotation.y += (0 - particleGroup.rotation.y) * 0.05;
                particleGroup.rotation.x += (0 - particleGroup.rotation.x) * 0.05;
            }

            // --- Star Animation (Blinking & Scaling) ---
            if(starMesh) {
                // REDUCED BRIGHTNESS: Scaled the formula to 70% of previous intensity
                // Previous was 1.0 base, now 0.7 base
                starMesh.material.emissiveIntensity = 0.7 + Math.sin(time * 3) * 0.35; 
                // Subtle scale pulse
                const pulse = 1 + Math.sin(time * 4) * 0.05;
                starMesh.scale.set(pulse, pulse, pulse);
            }

            particles.forEach((p, i) => {
                let targetPos = new THREE.Vector3();
                let targetScale = p.userData.baseScale;
                let damping = 0.05;

                if (currentState === STATES.TREE) {
                    targetPos.copy(p.userData.treePos);
                    targetPos.y += Math.sin(time + i*0.1) * 0.05;
                    // Photo logic: face outward
                    if(p.userData.isPhoto) {
                         const outward = new THREE.Vector3().copy(p.position).normalize();
                         outward.y = 0;
                         p.lookAt(p.position.clone().add(outward));
                    }
                } else if (currentState === STATES.SCATTER) {
                    targetPos.copy(p.userData.scatterPos);
                    const r = targetPos.length();
                    targetPos.x = r * Math.sin(time * 0.2 + i);
                    targetPos.z = r * Math.cos(time * 0.2 + i);
                    if(p.userData.isPhoto) p.lookAt(camera.position);
                } else if (currentState === STATES.FOCUS) {
                    if (i === focusedPhotoIndex) {
                        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                        targetPos.copy(camera.position).add(dir.multiplyScalar(5));
                        p.lookAt(camera.position);
                        targetScale = 3.5; 
                        damping = 0.1;
                    } else {
                        targetPos.copy(p.userData.scatterPos).multiplyScalar(3);
                    }
                }

                p.position.lerp(targetPos, damping);
                const s = THREE.MathUtils.lerp(p.scale.y, targetScale, damping);
                p.scale.set(p.userData.isPhoto ? s * p.userData.aspect : s, s, s);
                if(!p.userData.isPhoto) {
                    p.rotation.x += p.userData.rotationSpeed.x;
                    p.rotation.y += p.userData.rotationSpeed.y;
                }
            });

            // Handle Star Visibility Logic based on State
            if(starMesh) {
                if(currentState === STATES.TREE) {
                    starMesh.visible = true;
                    // Ensure star stays at top relative to group rotation
                    starMesh.position.y = THREE.MathUtils.lerp(starMesh.position.y, 5.5, 0.1);
                } else {
                    // Hide star or make it scatter far away in other modes
                    starMesh.visible = false; 
                }
            }

            snowParticles.forEach(s => {
                s.position.add(s.userData.velocity);
                if(s.position.y < -10) s.position.set((Math.random()-0.5)*40, 20, (Math.random()-0.5)*40);
                s.position.x += Math.sin(time + s.id)*0.01;
            });

            controls.update();
            composer.render();
        }

        init();
    </script>
</body>
</html>
